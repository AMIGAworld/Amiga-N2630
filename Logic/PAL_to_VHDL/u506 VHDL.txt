
		PARTNO	  XXXXX ;
		NAME	  U506;
		DATE	  May 6, 1988 ;
		REV	  1 ;
		DESIGNER  Haynie ;
		COMPANY   Commodore ;
		ASSEMBLY  312828 ;
		LOCATION  U506;

/************************************************************************/
/*									*/
/*  A2630 	E clock generation, VMA generation, EDTACK generation,	*/
/*  		Refresh request, 3 bits of refresh counter, and 	*/
/*		Refresh request.					*/
/*									*/
/************************************************************************/
/*  Allowable Target Device Types: 16R6A 				*/
/************************************************************************/
/*  Clock:	7M							*/
/************************************************************************/
/*  Free Pins: 2(I) 							*/
/************************************************************************/
/*  HISTORY								*/
/*	DBH Sep 25:	Made from U309R1 from A2630 Rev 2.		*/
/************************************************************************/

/**  Inputs  **/

PIN [3..6]	= [A0..3]	;	/* E and refresh counter bits */
PIN 7		= B2000		;	/* Board inside a B2000 */
PIN 8		= TRISTATE	;	/* Bus tristate control */
PIN 9		= !VPA		;	/* Valid peripheral address */

/**  Outputs  **/

PIN 19		= E		;	/* the 6800 E clock */
PIN 12		= !REFREQ	;	/* Refresh request to refresh logic */
PIN 13		= IVMA	 	;	/* Internal VMA */
PIN 14		= EDTACK	;	/* DTACK for 6800 cycle */
PIN 18		= !StBit3	;	/* Refresh counter bit 3 */
PIN 17		= !StBit2	;	/* Refresh counter bit 2 */
PIN 16		= !StBit1	;	/* Refresh counter bit 1 */
PIN 15		= !StBit0	;	/* Refresh counter bit 0 */

/** Declarations and Intermediate Variable Definitions **/

count		= A0 & A3;
THIS IS FOR THE DRAM REFRESH LOGIC, WHICH I DON'T CARE ABOUT

/**  Logic Equations  **/

RULES:
ALL MY INTERNAL SIGNALS ARE ACTIVE HIGH
ALL MY INTERNAL SIGNALS ARE IN lowercase
ALL EXTERNAL SIGNALS ARE IN UPPERCASE
ALL ACTIVE LOW SIGNALS ARE PRECEEDED BY n
ALL ACTIVE HIGH SIGNALS HAVE NO PREFIX

THE ORIGINAL PAL CODE IS THE FIRST LINE(S)
WITH THE PROPOSED VHDL CODE ON THE FOLLOWING LINES

USEFUL CONVERSION GRID FOR LOGIC STATES 'CAUSE IT CAN BE A MESS!

            PIN SIGNAL
          --------------
          |  !  |  -   |
------------------------
D S |     | NOT |   -  |
E T |  !  | NOT |  NOT |
S A |     |  1  |   0  |
I T |-----|-------------
R E |     | NOT |   -  |
E   |  -  |  -  |   -  |
D   |     |  0  |   1  |
------------------------

NOTE THAT A0..3 ARE NOT THE 680x0 ADDRESS BUS. THEY ARE GENERATED BY U504!

E		= A2;
E.OE		= !B2000;
E <= '1' WHEN A2 = '1' ELSE '0' WHEN A2 = '0' ELSE 'Z' WHEN B2000 = '0';

/* Initially, the logic here enabled IVMA during (!A3 & A2 & !A1 & A0 & VPA).
   This is the proper time to have VMA come out, just about when the 68000 
   would bring it out, actually slightly sooner since this PAL releases it on
   the wrong 7M edge.  The main problem with this scheme is that if VPA falls 
   in the case that's just prior to that enabling term (what I call CASE 3 
   in my timing), the I/O cycle should be held off until the next E cycle.
   The 68000 does this, but the above IVMA would run that cycle right away.
   The fix to this used here moves the IVMA equation up by one clock cycle,
   assuring that a CASE 3 VPA will be delayed.  This adds a potential problem
   in that IVMA would is asserted sooner than a 68000 would assert it.  We
   know this is no problem for 8520 devices, and /VPA driven devices aren't
   supported under autoconfig, so we should be OK here.
   
   VMA = valid memory address *JN*
   VPA = valid peripheral address *JN*
*/   

!IVMA.D		=   !A3 & !A2 & !A1 & !A0 & VPA
		# !IVMA & !A3;
PROCESS ( CLK7M ) BEGIN
   IF RISING_EDGE ( CLK7M ) THEN
      IVMA <= '0'
         WHEN 
            ( A3 = '0' AND A2 = '0' AND A1 = '0' AND A0 = '0' AND VPA= '0' ) OR
            ( IVMA = '0' AND A3 = '0' )
         ELSE
            '1';
   END IF;
END PROCESS;
   

/* This was "!A3 & A2 & A1 & !A0 & !IVMA", but I think that may make
   the cycle end too early.  So I'm pushing it up by one clock. */

!EDTACK.D	= !A3 & A2 & A1 & A0 & !IVMA;
PROCESS ( CLK7M ) BEGIN
   IF RISING_EDGE ( CLK7M ) THEN
      EDTACK <= '0'
         WHEN 
            ( A3 = '0' AND A2 = '1' AND A1 = '1' AND A0 = '1' AND IVMA = '0' ) 
         ELSE
            '1';
   END IF;
END PROCESS;

/*	This is the refresh counter describer in the refreshcounter
 *	state machine file. We have added the holding term to
 *	The REFREQ output (REFREQ & !WIN).
 */
 
THIS IS PART OF THE DRAM REFRESH, WHICH I DON'T CARE ABOUT

StBit3.D	= !count & !StBit1 & !StBit2 &  StBit3
		#  count & !StBit1 & !StBit2 & !StBit3
		#  count & !StBit0 &  StBit1 & !StBit3
		#  count & !StBit0 &  StBit2 & !StBit3
		# !count & !StBit0 &  StBit3;

StBit2.D	= !count &  StBit0 & !StBit1 &  StBit2 & !StBit3
		#  count & !StBit0 &  StBit1 & !StBit2 &  StBit3
		#  count & !StBit1 & !StBit2 &  StBit3
		#  count & !StBit0 &  StBit2 & !StBit3
		# !count & !StBit0 &  StBit2;

StBit1.D	=  count & !StBit0 & !StBit1 &  StBit2 & StBit3
		#  count & !StBit0 &  StBit1 & !StBit2 & StBit3
		#  count & !StBit0 &  StBit1 & !StBit3
		# !count & !StBit0 &  StBit1;

StBit0.D	=  count & !StBit0 &  StBit1 & StBit2 &  StBit3
		# !count &  StBit0 & !StBit1 & StBit2 & !StBit3
		# StBit0 & !StBit1 & !StBit2;

REFREQ =	count & StBit0 & !StBit1 & StBit2 & !StBit3;

