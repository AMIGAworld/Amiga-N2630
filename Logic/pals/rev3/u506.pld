
		PARTNO	  XXXXX ;
		NAME	  U506;
		DATE	  May 6, 1988 ;
		REV	  1 ;
		DESIGNER  Haynie ;
		COMPANY   Commodore ;
		ASSEMBLY  312828 ;
		LOCATION  U506;

/************************************************************************/
/*									*/
/*  A2630 	E clock generation, VMA generation, EDTACK generation,	*/
/*  		Refresh request, 3 bits of refresh counter, and 	*/
/*		Refresh request.					*/
/*									*/
/************************************************************************/
/*  Allowable Target Device Types: 16R6A 				*/
/************************************************************************/
/*  Clock:	7M							*/
/************************************************************************/
/*  Free Pins: 2(I) 							*/
/************************************************************************/
/*  HISTORY								*/
/*	DBH Sep 25:	Made from U309R1 from A2630 Rev 2.		*/
/************************************************************************/

/**  Inputs  **/

PIN [3..6]	= [A0..3]	;	/* E and refresh counter bits */
PIN 7		= B2000		;	/* Board inside a B2000 */
PIN 8		= TRISTATE	;	/* Bus tristate control */
PIN 9		= !VPA		;	/* Valid peripheral address */

/**  Outputs  **/

PIN 19		= E		;	/* the 6800 E clock */
PIN 12		= !REFREQ	;	/* Refresh request to refresh logic */
PIN 13		= IVMA	 	;	/* Internal VMA */
PIN 14		= EDTACK	;	/* DTACK for 6800 cycle */
PIN 18		= !StBit3	;	/* Refresh counter bit 3 */
PIN 17		= !StBit2	;	/* Refresh counter bit 2 */
PIN 16		= !StBit1	;	/* Refresh counter bit 1 */
PIN 15		= !StBit0	;	/* Refresh counter bit 0 */

/** Declarations and Intermediate Variable Definitions **/

count		= A0 & A3;

/**  Logic Equations  **/

E		= A2;
E.OE		= !B2000;

/* Initially, the logic here enabled IVMA during (!A3 & A2 & !A1 & A0 & VPA).
   This is the proper time to have VMA come out, just about when the 68000 
   would bring it out, actually slightly sooner since this PAL releases it on
   the wrong 7M edge.  The main problem with this scheme is that if VPA falls 
   in the case that's just prior to that enabling term (what I call CASE 3 
   in my timing), the I/O cycle should be held off until the next E cycle.
   The 68000 does this, but the above IVMA would run that cycle right away.
   The fix to this used here moves the IVMA equation up by one clock cycle,
   assuring that a CASE 3 VPA will be delayed.  This adds a potential problem
   in that IVMA would is asserted sooner than a 68000 would assert it.  We
   know this is no problem for 8520 devices, and /VPA driven devices aren't
   supported under autoconfig, so we should be OK here.
*/   

!IVMA.D		=   !A3 & !A2 & !A1 & !A0 & VPA
		# !IVMA & !A3;

/* This was "!A3 & A2 & A1 & !A0 & !IVMA", but I think that may make
   the cycle end too early.  So I'm pushing it up by one clock. */

!EDTACK.D	= !A3 & A2 & A1 & A0 & !IVMA;

/*	This is the refresh counter describer in the refreshcounter
 *	state machine file. We have added the holding term to
 *	The REFREQ output (REFREQ & !WIN).
 */

StBit3.D	= !count & !StBit1 & !StBit2 &  StBit3
		#  count & !StBit1 & !StBit2 & !StBit3
		#  count & !StBit0 &  StBit1 & !StBit3
		#  count & !StBit0 &  StBit2 & !StBit3
		# !count & !StBit0 &  StBit3;

StBit2.D	= !count &  StBit0 & !StBit1 &  StBit2 & !StBit3
		#  count & !StBit0 &  StBit1 & !StBit2 &  StBit3
		#  count & !StBit1 & !StBit2 &  StBit3
		#  count & !StBit0 &  StBit2 & !StBit3
		# !count & !StBit0 &  StBit2;

StBit1.D	=  count & !StBit0 & !StBit1 &  StBit2 & StBit3
		#  count & !StBit0 &  StBit1 & !StBit2 & StBit3
		#  count & !StBit0 &  StBit1 & !StBit3
		# !count & !StBit0 &  StBit1;

StBit0.D	=  count & !StBit0 &  StBit1 & StBit2 &  StBit3
		# !count &  StBit0 & !StBit1 & StBit2 & !StBit3
		# StBit0 & !StBit1 & !StBit2;

REFREQ =	count & StBit0 & !StBit1 & StBit2 & !StBit3;

