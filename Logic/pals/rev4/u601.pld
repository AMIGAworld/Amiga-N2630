
		PARTNO	  XXXXX ;
		NAME	  U601;
		DATE	  September 16, 1988 ;
		REV	  1 ;
		DESIGNER  Haynie ;
		COMPANY   Commodore ;
		ASSEMBLY  312828 ;
		LOCATION  U601;

/************************************************************************/
/*									*/
/*  A2630 	Refresh state machine.					*/
/*									*/
/************************************************************************/
/*  Allowable Target Device Types: 16R8A 				*/
/************************************************************************/
/*  Free Pins: 6(I),7(I)						*/
/************************************************************************/
/*  HISTORY								*/
/*	DBH Sep 26:	New, based on U600R6 and U601R3, from A2630R2.	*/
/************************************************************************/

/**  Inputs  **/

PIN 2		= !BGACK	;	/* '030 Bus Grant Acknowledge */
PIN 3		= !AS		;	/* '030 Address Strobe */
PIN 4		= !AASP		;	/* Delayed 68000 Address Strobe */
PIN 5		= !MEMSEL	;	/* On-board memory is selected */
PIN 8		= !IREFREQ	;	/* Synchronised refresh request */
PIN 9		= !DELCAS	;	/* Basis for external CAS */

/**  Outputs  **/

PIN 19		= !WANT		;	/* We want the bus to do refresh */
PIN 18		= !REFRAS	;	/* Refresh RAS control */
PIN 17		= !REFCAS	;	/* Refresh CAS control */
PIN 16		= !REFHOLD	;	/* Holdoff during refresh */
PIN 15		= !REFACK	;	/* Refresh request acknowledge */

/**  Used Internally **/

PIN 12		= !StBit2	;	/* State bit 2 */
PIN 13		= !StBit1	;	/* State bit 1 */
PIN 14		= !StBit0	;	/* State bit 0 */

/** Declarations and Intermediate Variable Definitions **/

/**  Logic Equations  **/

/* This is the refresh cycle state counter. */

StBit2.D	= IREFREQ & !StBit0 & !StBit2
		# !REFACK & !StBit0 & !StBit1 & StBit2
		#  StBit0 & !StBit1 & !StBit2
		# !StBit0 &  StBit1 & !StBit2;

StBit1.D	=  REFACK & !StBit0 & !StBit1 & StBit2
		#  StBit0 & !StBit1 &  StBit2
		# !StBit0 &  StBit1 & !StBit2;

StBit0.D	=  StBit0 & !StBit1 & !StBit2
		#  StBit0 & !StBit1 &  StBit2
		# !StBit0 &  StBit1 &  StBit2;

/* This is the refresh machine's refresh request. */

WANT.D		= IREFREQ & !StBit0 & !StBit2
		#  REFACK & !StBit0 & !StBit1 & StBit2
		# !REFACK & !StBit0 & !StBit1 & StBit2
		#  StBit0 & !StBit1 & !StBit2
		#  StBit0 & !StBit1 &  StBit2
		# !StBit0 &  StBit1 & !StBit2
		# !StBit0 &  StBit1 &  StBit2;

/* This is the refresh machine's refrech acknowledge, which is asserted 
   in respones to a refresh request (WANT).  A refresh request can
   be acknowledged in a number of cases.  If the 68030 is in charge
   and you`re not running a cycle, it's OK to refresh.  If the 68030
   is in charge and you're running a cycle, but not to on-board memory,
   its also OK.  If it's a DMA cycle, similar treatment is given, only
   using the synchronized AAS.  The final term is a holding term to 
   keep this signal asserted as long as WANT is valid. */

REFACK.D	= WANT &   !AS & !BGACK
		# WANT &    AS & !BGACK & !MEMSEL
		# WANT & !AASP &  BGACK
		# WANT &  AASP &  BGACK & !MEMSEL
		# WANT & REFACK;

/* This drives RAS for a refresh cycle */

REFRAS.D	= !StBit0 &  StBit1 & !StBit2
		# !StBit0 &  StBit1 &  StBit2
		#  StBit0 & !StBit1 & !StBit2;

/* This drives CAS for a refresh cycle */

REFCAS.D	=  REFACK & !StBit0 & !StBit1 & StBit2
		# !StBit0 &  StBit1 & !StBit2
		# !StBit0 &  StBit1 &  StBit2;

/* This holds off any real CAS cycles until the refresh cycle is
   completely over.  The problem this fixes is that when refresh
   happens during a memory cycle, the CAS PAL will generate CAS for
   a refresh cycle, as it's supposed to, but may right after that
   generate a second CAS.  This second CAS can go low before the
   refresh RAS goes high, and if this happens, a memory glitch is
   just about certain to happen.  So, this allows the CAS PAL to
   know that a refresh cycle is fully over with before allowing any
   normal CAS to occur.  */

REFHOLD.D	= REFCAS 
		# REFHOLD & REFRAS
		# REFHOLD & DELCAS ;

