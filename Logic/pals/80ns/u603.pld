
		PARTNO	  XXXXX ;
		NAME	  U603;
		DATE	  November 2, 1988;
		REV	  3 ;
		DESIGNER  Haynie ;
		COMPANY   Commodore ;
		ASSEMBLY  312828 ;
		LOCATION  U603;

/************************************************************************/
/*									*/
/*  A2630 	DRAM CAS generation					*/
/*									*/
/************************************************************************/
/*  Allowable Target Device Types: 16L8B 				*/
/************************************************************************/
/*  Free Pins: NONE							*/
/************************************************************************/
/*  HISTORY								*/
/*	DBH Sep 26:	New, based on U504R3, from A2630R2		*/
/*	DBH Nov  2:	Added DMADELAY logic to hold off DMA memory.	*/
/************************************************************************/

/**  Inputs  **/

PIN 1		= !CAS		;	/* CAS enable */
PIN 2		= !REFCAS	;	/* Refresh CAS */
PIN 3		= !REFHOLD	;	/* CAS holdoff during refresh */ 
PIN [4..5]	=  [SIZ0..1]	;	/* 68030 data size bits */
PIN 6		= !BGACK	;	/* Bus grant acknowledge */
PIN 7		= !UDS		;	/* Upper Data strobe */
PIN 8		= !LDS		;	/* Lower Data strobe */
PIN 9		= !DS		;	/* 68030 data strobe qualifier */
PIN 11		= !MEMSEL	;	/* Memory selected */
PIN 16		=  RW		;	/* 68030 R/W line */
PIN [18..17]	=  [A0..1]	;	/* Adress lines 0-1 */

/**  Outputs  **/

PIN 14		= !CAS0		;	/* Lowest byte */
PIN 13		= !CAS1		;
PIN 12		= !CAS2		;
PIN 19		= !CAS3		;	/* Highest byte */
PIN 15		= !DMADELAY	;	/* Delays DMA cycle */

/** Declarations and Intermediate Variable Definitions **/

/* There are several conditions under which a particular byte is selected,
   based on the address on the bus and the size bits.  This is explained in
   the 68030 manual.  Additionally, this PAL will enable all bytes for a
   READ cycle, so that the '030 may properly use it's data cache on this 
   memory. */

byte0		= SIZ1 & SIZ0 & A0
		# !SIZ1 & !SIZ0
		# A1 & A0
		# SIZ1 & A1 ;

byte1		= A1 & !A0
		# !SIZ1 & !SIZ0 & !A1
		# !A1 & SIZ0 & SIZ1
		# A0 & !A1 & !SIZ0 ;
		   
byte2		= !SIZ0 & !A1
		# !A1 & A0
		# SIZ1 & !A1 ;

byte3		= !A1 & !A0 ;

/* This is the qualified R/W signal */

cpuread		= RW & !BGACK & DMADELAY;

/* We want CAS enabled when memory is selected and the CAS input from the
   delay line is asserted.  We want CAS off at the end of the cycle: DS
   or UDS/LDS will do the job here pretty well.  */

casen		= MEMSEL & CAS & !REFHOLD;

/**  Logic Equations  **/

/* The purpose of DMADELAY is to hold off RAS during a DMA cycle
   until there's a data strobe.  Doubling up on this functional
   output, we also use DMADELAY to qualify "cpuread" during non-DMA
   cycles. */

DMADELAY	=  BGACK & !UDS & !LDS
		# !BGACK &      CAS & MEMSEL & !REFHOLD
		# !BGACK & DMADELAY & MEMSEL & !REFHOLD;

/* The byte-based CAS selects. */

CAS0	 	=  BGACK &   casen & LDS &    A1
	 	# !BGACK &   casen &  DS & byte0
		# !BGACK & cpuread &  DS
		# REFCAS;

CAS1	 	=  BGACK &   casen & UDS &    A1
		# !BGACK &   casen &  DS & byte1
		# !BGACK & cpuread &  DS
		# REFCAS;

CAS2	 	=  BGACK &   casen & LDS &   !A1
		# !BGACK &   casen &  DS & byte2
		# !BGACK & cpuread &  DS
		# REFCAS;

CAS3	 	=  BGACK &   casen & UDS &   !A1
		# !BGACK &   casen &  DS & byte3
		# !BGACK & cpuread &  DS
		# REFCAS;

